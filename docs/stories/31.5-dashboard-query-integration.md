# Story 31.5: Dashboard & Query Integration

## Status

Draft

## Story

**As a** HomeIQ user,
**I want** the health dashboard to display current weather and enable weather-correlated analytics queries,
**so that** I can monitor weather conditions and analyze how weather impacts my home automation patterns without any disruption from the architecture migration.

## Acceptance Criteria

1. Health dashboard displays current weather widget on Data Sources tab
2. Weather widget shows temperature, humidity, condition, and last update time
3. Weather data fetched from weather-api service (Port 8009) via REST API
4. Analytics queries updated to use time-window JOINs for weather correlation
5. Query helper functions provide easy weather correlation (5-minute time windows)
6. Dashboard handles weather-api unavailability gracefully (loading states, error messages)
7. Frontend weather API client includes retry logic and timeout handling
8. Documentation updated with new query patterns and examples
9. All 12 dashboard tabs continue to function without regression
10. Weather correlation queries achieve 95% accuracy compared to embedded weather

## Tasks / Subtasks

- [ ] Task 1: Create Weather API Client (AC: 3, 6, 7)
  - [ ] Create `services/health-dashboard/src/services/weatherApi.ts`
  - [ ] Implement getCurrentWeather() method
  - [ ] Implement getForecast() method
  - [ ] Add retry logic (3 attempts with exponential backoff)
  - [ ] Add timeout handling (5 second timeout)
  - [ ] Add error handling with typed exceptions
  - [ ] Mock weather API in tests

- [ ] Task 2: Create Weather Widget Component (AC: 1, 2, 6)
  - [ ] Create `services/health-dashboard/src/components/WeatherWidget.tsx`
  - [ ] Display current temperature, humidity, pressure
  - [ ] Display weather condition with icon
  - [ ] Show last update timestamp
  - [ ] Add loading state while fetching
  - [ ] Add error state when API unavailable
  - [ ] Add refresh button
  - [ ] Style with TailwindCSS matching dashboard theme

- [ ] Task 3: Integrate Widget into Data Sources Tab (AC: 1)
  - [ ] Add WeatherWidget to DataSourcesTab component
  - [ ] Position widget prominently (top-right or dedicated section)
  - [ ] Auto-refresh every 15 minutes
  - [ ] Add manual refresh capability
  - [ ] Ensure responsive design (mobile, tablet, desktop)

- [ ] Task 4: Create Weather Correlation Query Helpers (AC: 4, 5, 10)
  - [ ] Create `services/health-dashboard/src/utils/weatherQueries.ts`
  - [ ] Implement getEventsWithWeather(start, end, entityId) helper
  - [ ] Use 5-minute time window for JOIN
  - [ ] Add query builder for common patterns
  - [ ] Include TypeScript types for query results
  - [ ] Add example queries in comments

- [ ] Task 5: Update Analytics Queries (AC: 4, 10)
  - [ ] Identify queries using weather_condition tag
  - [ ] Update to use time-window JOIN with weather_data
  - [ ] Add fallback for historical data (COALESCE old/new schema)
  - [ ] Test queries return same results (95% accuracy)
  - [ ] Update AnalyticsTab to use new query helpers
  - [ ] Add query performance logging

- [ ] Task 6: Error Handling & Loading States (AC: 6)
  - [ ] Add WeatherUnavailable component (friendly error message)
  - [ ] Add WeatherLoading component (skeleton loader)
  - [ ] Implement exponential backoff retry
  - [ ] Show "Last successful update" when API down
  - [ ] Add "Retry now" button for manual retry
  - [ ] Log weather API errors to console

- [ ] Task 7: TypeScript Type Definitions (AC: 3)
  - [ ] Create `src/types/weather.ts` for weather data types
  - [ ] Define WeatherData interface matching API response
  - [ ] Define WeatherForecast interface
  - [ ] Define WeatherApiError types
  - [ ] Export types for use across dashboard

- [ ] Task 8: Testing & Validation (AC: 9, 10)
  - [ ] Write unit tests for weather API client
  - [ ] Write unit tests for WeatherWidget component
  - [ ] Write integration tests for Data Sources tab
  - [ ] Test weather correlation queries (accuracy validation)
  - [ ] Test error scenarios (API down, timeout, network error)
  - [ ] Test all 12 dashboard tabs for regression
  - [ ] Verify 95% query accuracy vs embedded weather

- [ ] Task 9: Documentation Updates (AC: 8)
  - [ ] Update docs/architecture/data-models.md (remove weather from events)
  - [ ] Create docs/architecture/weather-query-guide.md with examples
  - [ ] Update docs/architecture/database-schema.md (JOIN patterns)
  - [ ] Add inline code comments explaining time-window JOINs
  - [ ] Update dashboard README with weather widget info

## Dev Notes

### Testing Standards

**Weather API Client Tests:**
```typescript
describe('WeatherApi', () => {
  it('should fetch current weather successfully', async () => {
    // Mock successful response
    global.fetch = jest.fn().mockResolvedValue({
      ok: true,
      json: async () => ({
        temperature: 22.5,
        humidity: 45,
        condition: 'Clear'
      })
    });
    
    const weather = await weatherApi.getCurrentWeather();
    
    expect(weather.temperature).toBe(22.5);
    expect(weather.condition).toBe('Clear');
  });
  
  it('should retry on failure', async () => {
    // Mock failure then success
    global.fetch = jest.fn()
      .mockRejectedValueOnce(new Error('Network error'))
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({ temperature: 20 })
      });
    
    const weather = await weatherApi.getCurrentWeather();
    
    expect(global.fetch).toHaveBeenCalledTimes(2);
    expect(weather.temperature).toBe(20);
  });
});
```

**Query Accuracy Validation:**
```typescript
describe('Weather Correlation Queries', () => {
  it('should match 95% of embedded weather results', async () => {
    // Query historical events with embedded weather
    const embeddedResults = await queryEventsWithEmbeddedWeather('2025-10-01', '2025-10-07');
    
    // Query using time-window JOIN
    const joinResults = await getEventsWithWeather('2025-10-01', '2025-10-07');
    
    // Calculate match percentage
    const matchCount = countMatches(embeddedResults, joinResults);
    const accuracy = (matchCount / embeddedResults.length) * 100;
    
    expect(accuracy).toBeGreaterThan(95);
  });
});
```

### Architecture Context

**Weather API Client Implementation:**

```typescript
// services/health-dashboard/src/services/weatherApi.ts

import { WeatherData, WeatherForecast } from '../types/weather';

class WeatherApiClient {
  private baseUrl = 'http://localhost:8009';
  private timeout = 5000; // 5 seconds
  private maxRetries = 3;
  
  async getCurrentWeather(location: string = 'Las Vegas'): Promise<WeatherData> {
    return this.fetchWithRetry<WeatherData>('/current-weather', { location });
  }
  
  async getForecast(location: string = 'Las Vegas', hours: number = 24): Promise<WeatherForecast> {
    return this.fetchWithRetry<WeatherForecast>('/forecast', { location, hours });
  }
  
  private async fetchWithRetry<T>(
    endpoint: string,
    params: Record<string, any>,
    attempt: number = 1
  ): Promise<T> {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeout);
      
      const queryString = new URLSearchParams(params).toString();
      const response = await fetch(`${this.baseUrl}${endpoint}?${queryString}`, {
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`Weather API error: ${response.status}`);
      }
      
      return await response.json();
      
    } catch (error) {
      if (attempt < this.maxRetries) {
        // Exponential backoff: 1s, 2s, 4s
        const delay = Math.pow(2, attempt - 1) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.fetchWithRetry<T>(endpoint, params, attempt + 1);
      }
      
      throw new WeatherApiError(`Failed after ${attempt} attempts: ${error.message}`);
    }
  }
}

export const weatherApi = new WeatherApiClient();
```

**Weather Widget Component:**

```tsx
// services/health-dashboard/src/components/WeatherWidget.tsx

import React, { useState, useEffect } from 'react';
import { weatherApi } from '../services/weatherApi';
import { WeatherData } from '../types/weather';

export function WeatherWidget() {
  const [weather, setWeather] = useState<WeatherData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const fetchWeather = async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await weatherApi.getCurrentWeather();
      setWeather(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    fetchWeather();
    
    // Auto-refresh every 15 minutes
    const interval = setInterval(fetchWeather, 15 * 60 * 1000);
    
    return () => clearInterval(interval);
  }, []);
  
  if (loading && !weather) {
    return <WeatherSkeleton />;
  }
  
  if (error) {
    return (
      <div className="weather-widget error">
        <p>Weather data unavailable</p>
        <button onClick={fetchWeather}>Retry</button>
      </div>
    );
  }
  
  return (
    <div className="weather-widget">
      <div className="weather-condition">
        <span className="icon">{getWeatherIcon(weather.condition)}</span>
        <span className="condition">{weather.condition}</span>
      </div>
      <div className="weather-temp">{weather.temperature.toFixed(1)}°C</div>
      <div className="weather-details">
        <span>Humidity: {weather.humidity}%</span>
        <span>Pressure: {weather.pressure} hPa</span>
      </div>
      <div className="weather-updated">
        Updated: {formatTimestamp(weather.timestamp)}
      </div>
      <button onClick={fetchWeather} className="refresh-btn">
        <RefreshIcon />
      </button>
    </div>
  );
}
```

**Time-Window JOIN Query Helper:**

```typescript
// services/health-dashboard/src/utils/weatherQueries.ts

export async function getEventsWithWeather(
  startTime: string,
  endTime: string,
  entityId?: string
): Promise<EventWithWeather[]> {
  // InfluxDB Flux query with time-window JOIN
  const query = `
    import "join"
    
    events = from(bucket: "home_assistant_events")
      |> range(start: ${startTime}, stop: ${endTime})
      ${entityId ? `|> filter(fn: (r) => r.entity_id == "${entityId}")` : ''}
    
    weather = from(bucket: "weather_data")
      |> range(start: ${startTime}, stop: ${endTime})
    
    // Join with 5-minute time window
    join.time(
      left: events,
      right: weather,
      as: (l, r) => ({l with weather_temp: r.temperature, weather_condition: r.condition}),
      method: "left"
    )
      |> window(every: 5m)
      |> yield(name: "result")
  `;
  
  return await influxDbClient.query(query);
}

// Helper for common weather correlation queries
export const weatherQueries = {
  // Find events during specific weather conditions
  async findEventsDuringCondition(
    condition: string,
    startTime: string,
    endTime: string
  ): Promise<Event[]> {
    const events = await getEventsWithWeather(startTime, endTime);
    return events.filter(e => e.weather_condition === condition);
  },
  
  // Find temperature-correlated events
  async findEventsInTempRange(
    minTemp: number,
    maxTemp: number,
    startTime: string,
    endTime: string
  ): Promise<Event[]> {
    const events = await getEventsWithWeather(startTime, endTime);
    return events.filter(e => 
      e.weather_temp >= minTemp && e.weather_temp <= maxTemp
    );
  }
};
```

### Reference Implementations

**Sports Data Widget** (`services/health-dashboard/src/components/sports/LiveGameCard.tsx`):
- Similar widget pattern for external data ✅
- Auto-refresh with configurable interval ✅
- Loading states and error handling ✅
- Retry logic for API failures ✅

**Dashboard API Integration Pattern**:
- Use React hooks for data fetching
- Implement loading/error states
- Auto-refresh with cleanup
- TypeScript types for API responses

### Context7 Verification

**React Data Fetching Best Practices:**
- ✅ useEffect for side effects (API calls)
- ✅ useState for component state (loading, error, data)
- ✅ Cleanup function to cancel intervals
- ✅ Error boundaries for error handling

**TypeScript API Client:**
- ✅ Typed responses with interfaces
- ✅ Error handling with custom error classes
- ✅ Async/await for promise handling
- ✅ AbortController for request cancellation

### Critical Success Factors

1. **Zero Downtime**: Dashboard continues working during migration
2. **Query Accuracy**: 95% match with embedded weather queries
3. **User Experience**: Weather widget feels native to dashboard
4. **Error Handling**: Graceful degradation when weather-api unavailable
5. **Performance**: Weather queries <500ms

### Integration Points

**Dependencies:**
- Story 31.3 (Weather API Endpoints) - MUST BE COMPLETE
- weather-api service running on Port 8009
- InfluxDB with weather_data measurement populated

**Dashboard Tabs Affected:**
- Data Sources Tab (primary - weather widget)
- Analytics Tab (weather correlation queries)
- Events Tab (may show weather in event details)

### Performance Targets

- Weather widget load time: <200ms
- Weather correlation queries: <500ms
- Dashboard load time: No increase
- Auto-refresh impact: <1% CPU

### Migration Validation Checklist

- [ ] Weather widget displays correctly on Data Sources tab
- [ ] Current temperature, humidity, condition shown
- [ ] Widget auto-refreshes every 15 minutes
- [ ] Manual refresh button works
- [ ] Error state shows when weather-api down
- [ ] Weather correlation queries return results
- [ ] Query accuracy ≥95% vs embedded weather
- [ ] All 12 dashboard tabs load without errors
- [ ] No console errors related to weather
- [ ] Documentation updated and accurate

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Initial story creation | BMad Master |

## Dev Agent Record

*This section will be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be added here*

