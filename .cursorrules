# Cursor Rules for ha-ingestor Project

## Project Overview
This is a production-grade Python service for ingesting Home Assistant activity to InfluxDB. The project uses Context7 (Agent OS) for development standards and follows modern Python development practices.

## Technology Stack
- **Python 3.12+** with async-first architecture
- **FastAPI** for HTTP endpoints
- **paho-mqtt** for MQTT client functionality
- **websockets** for WebSocket client
- **influxdb-client** for InfluxDB operations
- **pydantic** for data validation and settings
- **structlog** for structured logging
- **prometheus-client** for metrics collection
- **tenacity** for retry logic

## Development Standards

### Code Style & Formatting
- Use **Black** with 88 character line length
- Use **Ruff** for linting and import sorting
- Use **MyPy** for type checking
- Follow PEP 8 conventions with project-specific overrides
- Use 4 spaces for indentation (Python standard)
- Use snake_case for functions and variables
- Use PascalCase for classes
- Use UPPER_SNAKE_CASE for constants

### Python Best Practices
- Write async-first code using `asyncio`
- Use type hints throughout the codebase
- Use Pydantic models for data validation
- Implement proper error handling with custom exceptions
- Use structured logging with structlog
- Follow dependency injection patterns
- Write comprehensive docstrings for public APIs
- Use dataclasses or Pydantic models for data structures

### Project Structure
- Keep modules focused on single responsibility
- Use `__init__.py` files for clean imports
- Group related functionality in subpackages
- Maintain consistent naming across modules
- Use relative imports within the package

### Testing
- Write unit tests for all business logic
- Use pytest with async support
- Mock external dependencies
- Aim for high test coverage
- Use fixtures for common test data

### Error Handling
- Implement proper exception hierarchies
- Use custom exception classes for business logic errors
- Log errors with appropriate context
- Implement retry logic with tenacity where appropriate
- Provide meaningful error messages

### Logging
- Use structured logging with structlog
- Log at appropriate levels (DEBUG, INFO, WARNING, ERROR)
- Include relevant context in log messages
- Use correlation IDs for request tracing

### Configuration
- Use Pydantic settings for configuration management
- Support environment variable overrides
- Validate configuration at startup
- Use type-safe configuration objects

### Performance
- Use async/await for I/O operations
- Implement connection pooling for external services
- Use appropriate data structures for performance
- Monitor and log performance metrics

## Development Standards
- Follow the established coding patterns in the project
- Reference project documentation in the docs/ directory
- Use established naming conventions and code structure
- Follow the project's error handling and logging patterns

## Code Quality
- Run pre-commit hooks before committing
- Ensure all tests pass
- Fix linting issues before submission
- Maintain type safety with MyPy
- Follow the project's error handling patterns

## Documentation
- Update README.md for significant changes
- Document new configuration options
- Update API documentation when endpoints change
- Keep development documentation current

## Security
- Validate all input data
- Use environment variables for sensitive configuration
- Implement proper authentication where required
- Follow secure coding practices for network operations

## Monitoring & Observability
- Implement health checks for all services
- Use Prometheus metrics for monitoring
- Log structured events for analysis
- Implement proper error tracking

## Dependencies
- Use Poetry for dependency management
- Pin dependency versions in pyproject.toml
- Regularly update dependencies for security
- Document any dependency changes

## Deployment
- Use Docker for containerization
- Support Docker Compose for local development
- Implement proper health checks
- Use environment-based configuration
